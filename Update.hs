{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ViewPatterns #-}
{-# OPTIONS_GHC -Wall #-}

import Config
import Control.Concurrent.Async (mapConcurrently)
import Control.Monad (void)
import qualified Data.Aeson as A
import qualified Data.Map.Strict as Map
import Data.Maybe (catMaybes)
import Data.Text (Text)
import qualified Data.Text as T
import Data.Text.Encoding (encodeUtf8)
import qualified Data.Text.IO as T
import Lib
import NeatInterpolation (trimming)
import System.Directory (doesFileExist)
import System.Process (CreateProcess, readCreateProcessWithExitCode, shell)

-----------------------------------------------------------------------------

nvcheckerConfig :: FilePath
nvcheckerConfig = "nvchecker.toml"

sha256Data :: FilePath
sha256Data = "sha256sums.json"

newVerData :: FilePath
newVerData = "new_ver.json"

oldVerData :: FilePath
oldVerData = "old_ver.json"

-----------------------------------------------------------------------------

-- nvchecker

generateNvcheckerConfig :: [(SourceName, NvcheckerSource)] -> IO ()
generateNvcheckerConfig entries = T.writeFile nvcheckerConfig file
  where
    o = T.pack oldVerData
    n = T.pack newVerData
    file =
      [trimming|
        # This file was generated by Update.hs, please do not modify it manually.
        [__config__]
        oldver = "$o"
        newver = "$n"

        $body
      |]
    body = T.unlines [toNvEntry srcName src <> "\n" | (srcName, src) <- entries]

data NvcheckerResult = NvcheckerResult
  { nvName :: SourceName,
    isUpToDate :: Bool
  }
  deriving (Eq, Show)

instance A.FromJSON NvcheckerResult where
  parseJSON = A.withObject "NvcheckerResult" $ \o ->
    NvcheckerResult <$> o A..: "name" <*> ((== A.String "up-to-date") <$> o A..: "event")

runNvchecker :: IO [NvcheckerResult]
runNvchecker = do
  txt <- runMyProcess . shell $ "nvchecker --logger json -c" <> nvcheckerConfig
  pure . catMaybes $ A.decodeStrict . encodeUtf8 <$> T.lines txt

runNvtake :: IO ()
runNvtake = void $ runMyProcess . shell $ "nvtake --all -c" <> nvcheckerConfig

decodeAsMap :: Maybe A.Value -> Map.Map Text Text
decodeAsMap (Just o) = case A.fromJSON o of
  A.Success x -> x
  A.Error e -> error e
decodeAsMap _ = error "failed to parse json"

-----------------------------------------------------------------------------

-- prefetch

prefetchCommand :: Text -> CreateProcess
prefetchCommand template = shell $ "nix-prefetch '" <> T.unpack template <> "'"

prefetchPackage :: Text -> IO Text
prefetchPackage fetcherExpr = strip <$> runMyProcess (prefetchCommand fetcherExpr)
  where
    strip =
      ( \case
          (T.stripPrefix "sha256-" -> Just s) -> s
          _ -> error "failed to get sum"
      )
        . T.strip
        . last
        . T.lines

-----------------------------------------------------------------------------

snippetN :: Text -> Text -> Text -> Text
snippetN name ver src =
  [trimming|
    $name = {
      pname = "$name";
      version = "$ver";
      src = $src;
    };
  |]

fixedSN :: Text -> Text
fixedSN name = [trimming|sums.$name|]

sourcesN :: Text -> Text
sourcesN body =
  let s = T.pack sha256Data
   in [trimming|
    # This file was generated by Update.hs, please do not modify it manually.
    { fetchFromGitHub, fetchurl }:
    let sums = with builtins; (fromJSON (readFile ./$s));
    in {
      $body
    }
  |]

-----------------------------------------------------------------------------

main :: IO ()
main = do
  let DefState {_pkgs, _sources} = runDefinition nixSources
  -- generate nvchecker config file
  generateNvcheckerConfig $ Map.toList _sources

  -- run nvchecker to generate new_ver.json
  T.putStrLn "Running nvchecker"
  ignoredNames <- fmap nvName . filter isUpToDate <$> runNvchecker

  T.putStr "The following packages are up-to-date: "
  T.putStrLn $ T.intercalate ", " ignoredNames

  -- parse new_ver.json
  T.putStrLn "Parsing newver json"
  newVers <- decodeAsMap <$> A.decodeFileStrict' newVerData

  -- stale sources
  let sourcesNeedFetch = Map.filterWithKey (\srcName _ -> srcName `notElem` ignoredNames) newVers
      pkgsNeedFetch = Map.filter (`Map.member` sourcesNeedFetch) _pkgs
      fetchersNeedRun =
        Map.mapWithKey
          ( \Pkg {..} srcName ->
              T.replace
                (unVersion attatchedVer)
                (sourcesNeedFetch Map.! srcName)
                (toNix fetcher)
          )
          pkgsNeedFetch

  T.putStrLn "Packages to fetch: "
  print pkgsNeedFetch

  -- run fetchers to get SHA256
  sha256sums <- mapConcurrently prefetchPackage fetchersNeedRun

  -- recover fresh sha256sums from file
  T.putStrLn "Parsing sha256 json"
  hasOld <- doesFileExist oldVerData
  recovered <-
    if hasOld
      then Map.filterWithKey (\k _ -> k `elem` ignoredNames) . decodeAsMap <$> A.decodeFileStrict' sha256Data
      else pure Map.empty

  let sha256sumsWithRecovered = recovered <> Map.fromList [(_pkgs Map.! pkg, sha256) | (pkg, sha256) <- Map.toList sha256sums]

  T.putStrLn "Fetch result:"
  print sha256sums

  -- generate sources
  T.putStrLn "Generating sources.nix"

  let k =
        T.unlines
          [ snippetN name (newVers Map.! srcName) fetcherExpr
            | (Pkg {..}, srcName) <- Map.toList _pkgs,
              let name = unPkgName pkgName,
              let fetcherExpr =
                    T.replace
                      (unVersion attatchedVer)
                      (newVers Map.! srcName)
                      $ toNix $ setSHA256 fetcher $ Just $ fixedSN srcName
          ]
  T.writeFile "sources.nix" $ sourcesN k

  -- update old_ver.json
  T.putStrLn "Running nvtake"
  runNvtake

  -- write all sums for next use
  A.encodeFile sha256Data sha256sumsWithRecovered

runMyProcess :: CreateProcess -> IO Text
runMyProcess c = do
  (_, stdout, stderr) <- readCreateProcessWithExitCode c ""
  putStrLn stdout
  putStrLn stderr
  pure $ T.pack stdout
