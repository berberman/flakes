{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ViewPatterns #-}
{-# OPTIONS_GHC -Wall #-}

module Updater.Main where

import Config
-- import Control.Concurrent.Async (mapConcurrently)
import Control.Monad (void, (<=<))
import qualified Data.Aeson as A
import qualified Data.Map.Strict as Map
import Data.Maybe (catMaybes)
import Data.Text (Text)
import qualified Data.Text as T
import Data.Text.Encoding (encodeUtf8)
import qualified Data.Text.IO as T
import NeatInterpolation (trimming)
import System.Directory (doesFileExist)
import System.Environment (lookupEnv)
import System.FilePath ((</>))
import System.Process (readCreateProcessWithExitCode, shell)
import Text.Pretty.Simple
import Updater.Lib

-----------------------------------------------------------------------------

nvcheckerConfig :: FilePath
nvcheckerConfig = "Updater/nvchecker.toml"

sha256Data :: FilePath
sha256Data = "sums.json"

newVerData :: FilePath
newVerData = "new_ver.json"

oldVerData :: FilePath
oldVerData = "old_ver.json"

-----------------------------------------------------------------------------

-- nvchecker

generateNvcheckerConfig :: [(SourceName, NvcheckerSource)] -> IO ()
generateNvcheckerConfig entries = T.writeFile nvcheckerConfig file
  where
    o = T.pack oldVerData
    n = T.pack newVerData
    file =
      [trimming|
        # This file was generated by Updater, please do not modify it manually.
        [__config__]
        oldver = "$o"
        newver = "$n"

        $body
      |]
    body = T.unlines [toNvEntry srcName src <> "\n" | (srcName, src) <- entries]

data NvcheckerResult = NvcheckerResult
  { nvName :: SourceName,
    isUpToDate :: Bool
  }
  deriving (Eq, Show)

instance A.FromJSON NvcheckerResult where
  parseJSON = A.withObject "NvcheckerResult" $ \o ->
    NvcheckerResult <$> o A..: "name" <*> ((== A.String "up-to-date") <$> o A..: "event")

runNvchecker :: IO [NvcheckerResult]
runNvchecker = do
  txt <- runShell ("nvchecker --logger json -c" <> T.pack nvcheckerConfig)
  pure . catMaybes $ A.decodeStrict . encodeUtf8 <$> T.lines txt

runNvtake :: IO ()
runNvtake = void $ runShell ("nvtake --all -c" <> T.pack nvcheckerConfig)

runNvcmp :: IO Text
runNvcmp = runShell ("nvcmp -c" <> T.pack nvcheckerConfig)

decodeAsMap :: (A.FromJSONKey a, Ord a) => Maybe A.Value -> Map.Map a Text
decodeAsMap (Just o) = case A.fromJSON o of
  A.Success x -> x
  A.Error e -> error e
decodeAsMap _ = error "failed to parse json"

-----------------------------------------------------------------------------

-- prefetch

prefetchCommand :: Text -> Text
prefetchCommand template = "nix-prefetch '" <> template <> "'"

prefetchPackage :: Text -> IO Text
prefetchPackage fetcherExpr = strip <$> runShell (prefetchCommand fetcherExpr)
  where
    strip :: Text -> Text
    strip s = case (T.stripPrefix "sha256-" <=< lastMaybe . T.lines) s of
      Just x -> x
      _ -> error "failed to prefetch"

lastMaybe :: [Text] -> Maybe Text
lastMaybe [] = Nothing
lastMaybe xs = Just $ last xs

-----------------------------------------------------------------------------

snippetN :: Text -> Text -> Text -> Text
snippetN name ver src =
  [trimming|
    $name = {
      pname = "$name";
      version = "$ver";
      src = $src;
    };
  |]

fixedSN :: Text -> Text
fixedSN name = [trimming|sums.$name|]

sourcesN :: Text -> Text
sourcesN body =
  let s = T.pack sha256Data
   in [trimming|
    # This file was generated by Updater, please do not modify it manually.
    { fetchFromGitHub, fetchurl }:
    let sums = with builtins; (fromJSON (readFile ./$s));
    in {
      $body
    }
  |]

-----------------------------------------------------------------------------

main :: IO ()
main = do
  let DefState {_pkgs, _sources} = runDefinition nixSources
  -- generate nvchecker config file
  generateNvcheckerConfig $ Map.toList _sources

  -- run nvchecker to generate new_ver.json
  T.putStrLn "Running nvchecker"
  ignoredNames <- fmap nvName . filter isUpToDate <$> runNvchecker

  T.putStr "The following packages are up-to-date: "
  pPrint ignoredNames

  -- parse new_ver.json
  T.putStrLn "Parsing newver json"
  newVers <- decodeAsMap <$> A.decodeFileStrict' ("Updater" </> newVerData)

  -- stale sources
  let sourcesNeedFetch = Map.filterWithKey (\srcName _ -> srcName `notElem` ignoredNames) newVers
      pkgsNeedFetch = Map.filter (`Map.member` sourcesNeedFetch) _pkgs
      fetchersNeedRun =
        Map.mapWithKey
          ( \Pkg {..} srcName ->
              T.replace
                (unVersion attatchedVer)
                (sourcesNeedFetch Map.! srcName)
                (toNix fetcher)
          )
          pkgsNeedFetch

  T.putStrLn "Packages to fetch: "
  pPrint pkgsNeedFetch

  -- run fetchers to get SHA256
  sha256sums <- mapM prefetchPackage fetchersNeedRun

  -- recover fresh sha256sums from file
  T.putStrLn "Parsing sha256 json"
  hasOld <- doesFileExist sha256Data
  recovered <-
    if hasOld
      then Map.filterWithKey (\k _ -> k `elem` ignoredNames) . decodeAsMap <$> A.decodeFileStrict' sha256Data
      else pure Map.empty

  let sha256sumsWithRecovered = recovered <> Map.fromList [(_pkgs Map.! pkg, sha256) | (pkg, sha256) <- Map.toList sha256sums]

  T.putStrLn "Fetch result:"
  pPrint sha256sums

  -- generate sources
  T.putStrLn "Generating sources.nix"

  let k =
        T.unlines
          [ snippetN name (newVers Map.! srcName) fetcherExpr
            | (Pkg {..}, srcName) <- Map.toList _pkgs,
              let name = unPkgName pkgName,
              let fetcherExpr =
                    T.replace
                      (unVersion attatchedVer)
                      (newVers Map.! srcName)
                      $ toNix $ setSHA256 fetcher $ Just $ fixedSN $ unSourceName srcName
          ]
  T.writeFile "sources.nix" $ sourcesN k <> "\n"

  -- use nvcmp output as commit message
  T.putStrLn "Running nvcmp"
  commitMessage <- ("Auto update: " <>) <$> runNvcmp
  T.putStrLn "Commit message:"
  T.putStrLn commitMessage

  -- update old_ver.json
  T.putStrLn "Running nvtake"
  runNvtake

  -- write all sums for next use
  A.encodeFile sha256Data sha256sumsWithRecovered
  T.appendFile sha256Data "\n"

  githubEnv <- lookupEnv "GITHUB_ENV"
  case githubEnv of
    Just fp -> T.appendFile fp $ "COMMIT_MSG=" <> commitMessage
    _ -> T.putStrLn "Not in github environment"

runShell :: Text -> IO Text
runShell x = do
  (_, T.pack -> stdout, T.pack -> stderr) <- readCreateProcessWithExitCode (shell $ T.unpack x) ""
  let s = T.replicate 10 "-"
  T.putStrLn $ s <> " " <> T.pack (show x) <> " " <> s
  T.putStrLn stdout
  T.putStrLn $ s <> " " <> T.pack (show x) <> " " <> s
  T.putStrLn stderr
  pure stdout
